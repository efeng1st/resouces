第六章 并发
=============
本章概要
- 使用goroutine运行代码
- 检测和修复竞态条件
- 使用通道共享数据

通常程序可以以线性路径代码实现来执行简单任务并完成。如果这是可能的，我们通常选择这种方式，因为这样类型的编程通常简单易写，并且容易维护。但是很多时候并行执行多个任务有更多好处。 一个常见例子就是web服务器，可以同时接收多个独立socket上的数据请求。每个socket请求都是独立的，可以独立处理。具有并行执行请求的能力可以极大的提升这种类型系统的性能。就是因为考虑到这一点，Go语言已经将并行内置到语言系统和运行系统中。

Go语言中的并发就是独立运行每个功能的能力。 当函数使用goroutine创建，它就被视为一个独立的工作单元，会被调度并在单个可用的逻辑处理器上执行。Go运行时调度器是一个复杂的软件，它管理创建的所有goroutine和所需的处理器时间。调度器位于操作系统顶层，绑定操作系统线程到逻辑处理器,反过来它们执行goroutine。调度器控制所有goroutine在何时运行在哪个逻辑处理器这些事情。

并发同步来自叫做通信顺序处理(CSP)的范式。CSP是一个消息传递模型，通过在goroutine之间通信数据来工作，而不是锁定数据来同步访问实现。goroutine之间用于同步和传递消息的关键数据类型叫做channel(通道)。对很多没有体验过用通道写并行程序的开发者来说， 它们唤起了一种敬畏和兴奋的气氛，你也很希望体验一下吧。 使用通道使你很容易开发并行程序，并且更少犯错。

## 6.1 并发和并行(Concurrency versus parallelism)
让我们从高层次来学习操作系统进程和线程是什么。这会帮助我们理解后续的Go运行时调度如何和操作系统操作来并行运行goroutine。当你运行一个应用程序是，比如IDE或编辑器，操作系统为这个应用程序启动一个进程。你可以认为进程就像一个容器，保存应用程序使用和维持运行的资源。

图6.1展示了包含可能分配个任意进程的通用资源。 这些资源包括但不限于内存地址空间、文件处理器、设备和线程。线程是执行路径，由操作系统调度来运行你所写功能的代码。每个进程包含至少一个线程，进程的最初始化的线程叫做主线程。当主线程终止，应用程序就终止了，因为这个执行路径是应用程序的起源。 操作系统调度线程在处理器上来运行，而不管进程属于哪个处理器。不同操作系统使用的算法用于调度线程，总是变化的，都是来自程序员抽象的。

![](images/6.1.jpg)

操作系统调度让线程在物理处理器上运行，Go运行时调度让goroutine在逻辑处理器上运行。每个逻辑处理器都是独立绑定到单个操作系统线程。1.5版本的，默认的为每个物理处理器分配逻辑处理器已可用。 1.5版本之前，只默认分配一个单独的逻辑处理器。 这些逻辑处理器用于执行创建的所有goroutine. 即便在单个逻辑处理器中，成千上万个goroutine可以被调度来并发运行, 并具有令人吃惊的效率和性能。

图6.2， 你可以看到操作系统线程(逻辑处理器)和本地运行队列之间的关系。 随着goroutine的创建和运行就绪，它们被放到调度器的全局运行队列。之后不久，它们被赋予给逻辑处理器，然后放入那个逻辑处理器的逻辑运行队列。从这里，goroutine等待自己变成特定逻辑处理器来执行。

![](images/6.2.jpg)

有时候运行goroutine需要执行阻塞的系统调用，例如打开文件。当这种事情发生，线程和goroutine都从逻辑处理器上解除，线程继续阻塞等待系统调用返回。同时，具有一个没有线程的逻辑处理器。 因此调度器创建一个新线程并绑定给那个逻辑处理器。然后调度器会从局部运行队列中选择另外一个goroutine来执行。一旦系统调用返回，那个goroutine就被放回局部运行队列，线程被放入将来使用的里边。

如果goroutine需要调用网络I/O, 进程稍微不同。 这种情况下，goroutine从逻辑处理器解绑，移到运行时集成网络轮询中(network poller)。一旦轮询表明读写操作就绪，goroutine重新赋予回逻辑处理器来处理操作。调度器中能创建多少逻辑处理器没有限制。但是运行时默认情况下，限制每个程序最多1万个线程。这个值可以通过调用runtime/debug包的SetMaxThreads函数来改变。如果程序尝试使用更多的线程，就会崩溃。

并发不是并行的。并行只能通过多片代码同时在不同的物理处理器上执行来达到。并行是关于同时做很多事情的概念。而并发是关于一次管理很多事情的概念。很多情况下，并发比并行性能更好， 因为操作系统和硬件的压力要小很多，这样可以让系统做更多事情。 少即是多哲学是语言圣经。

如果你希望并行运行goroutine, 你必须使用多个逻辑处理器。当有多个逻辑处理器，调度器会均匀的将goroutine分布到不同的逻辑处理器中。这样就导致goroutine在不同的线程上运行。但是要真正拥有并行， 你依然需要将程序运行在多物理处理器的机器上。如果不这样，goroutine会在单个处理器上并发运行, 即便Go语言运行时时使用多线程的。

图6.3展示了在单个逻辑处理器上并发运行goroutine和在两个逻辑处理器上并行并发的区别。 不建议盲目修改运行时默认的逻辑处理器。调度器包含智能算法，在Go语言的每个发布版本中都会更新和提升的。 如果你看到性能问题，并且确信可以通过修改逻辑处理器的数量来解决，那么你可以这样干。稍后你会了解更多细节。

![](images/6.3.jpg)


## 6.2 goroutine
让我们揭开调度器更多行为以及如何创建goroutine并管理它们的存在期。我们下面代码运行在单个逻辑处理器, 在讨论如何并行运行goroutine之前。这个程序创建两个goroutine, 分别以大小写形式显示字母。
```
// The sample program demonstrates how to create groutines and how the scheduler behave.
pacakge main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    // Allocate 1 logic processor for scheduler to use.
    runtime.GOMAXPROCS(1)

    // wg is used to wait for program to finish.
    // Add a count of 2, one for each goroutine.
    var wg = sync.WaitGroup
    wg.add(2)

    fmt.Println("Start Goroutines")
    
    // Declare an anonymous function and create an goroutine.
    go func() {
        // Schedule the call to Done to tell main we are done.
        defer wg.Done()

        // Display alphabet three times.
        for count := 0; count < 3; count++ {
            for char := 'a'; char < 'a' + 26; char++ {
                fmt.Printf("%c ", char)
            }
        }
    }()
    
    // Declare an anonymous function and create an goroutine.
    go func() {
        // Schedule the call to Done to tell main we are done.
        defer wg.Done()

        // Display alphabet three times.
        for count := 0; count < 3; count++ {
            for char := 'A'; char < 'A' + 26; char++ {
                fmt.Printf("%c ", char)
            }
        }
    }()

    fmt.Println("Waitting to Finish")
    wg.wait()

    fmt.Println("\nTerminating Program")
}
```

上面代码main的第一行，我们调用runtime.GOMAXPROCS函数，让程序改变调度器使用的逻辑处理器数量。还有一个同名的环境变量可以用于设置它, 如果我们不希望在代码中单独调用的话。 传入1，告诉调度器为该程序使用单个逻辑处理器。

然后我们声明两个匿名函数来显示字母。第一个函数以小写字母的形式显示，第二个函数以大写字母的形式显示。这两个函数都是通过go关键词创建goroutine。你会看到下面的输出结果，两个goroutine的代码在单个逻辑处理器中并发运行。

输出内容如下:
Create Goroutines
Waitting to Finish
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z 
Terminating Program

第一个goroutine显示字母所花费的时间非常少，在调度器切换到第二个routine之前它就能完成自己的工作。这就是为什么你会看到大写字母先输出，然后才输出小写字母。 我们创建的两个goroutine可以并发运行，一个接一个的，执行它们单独的显示字母的任务。

一旦匿名函数以goroutine的形式创建，main中的代码继续运行。 这就意味着祝函数可以在goroutine完成工作之前返回。如果发生这样的事情，程序会在goroutine获得运行机会前就终止了。 因此在main函数中我们需要调用wg.wait()来等待两个goroutine的完成。

WaitGroup是一个计数信号量(semaphore)，可以用于维持运行的goroutine记录。当WaitGroup的值大于零，Wait方法会被阻塞。上面代码中，我们声明了一个WaitGroup类型变量wg, 然后wg.add(2), 设置WaitGroup值为2，表示两个运行的goroutine. 要减少WaitGroup的值，最终释放(eventually release)， 调用defer wg.Done()方法。就是说匿名函数构建的goroutine执行完，调用wg.Done()。

关键词defer用于调度其他函数，让它在函数返回后在函数内部被调用执行。上面我们使用defer确保goroutine完成工作后，调用wg.Done()。

基于调度器内部算法，运行中的goroutine可以在完成工作之前停止和重新调度再次运行。调度器实现这些，防止任何单独goroutine独占逻辑处理器(processor hostage)。它会停止当前运行的goroutine, 然后给另外的可运行goroutine机会运行。

图6.4从逻辑处理器的角度展示了这个场景(scenario)。步骤1调度器开始执行goroutine A，goroutine B在运行队列中等待轮询。然后，突然在步骤2中，调度器切出goroutine A到goroutine B。既然goroutine A还没有完成， 它被放回到运行队列中。 然后在步骤3中，goroutine B完成它的工作然后消失了。 这样就允许goroutine A回去工作。

![](images/6.4.jpg)

你可以通过创建一个需要长时间才能完成工作的goroutine来看这种行为。

```
// This sample program demonstrates how the goroutine scheduler will time slice goroutines on a single thread.
package main

import (
    "fmt"
    "runtime"
    "sync"
)

// wg is used to wait for the program to finish.
var wg sync.WaitGroup

// main is the entry point for all Go programs.
func main() {
    // Allocate 1 logical processors for the scheduler to use.
    runtime.MAXPROCS(1)

    // Add a count of two, one for each goroutine.
    wg.Add(2)

    // Create two goroutines.
    fmt.Println("Create Goroutines")

    go printPrime("A")
    go printPrime("B")

    // Wait for the goroutines to finish.
    fmt.Println("Waiting To Finish")
    wg.Wait()

    fmt.Println("Terminating Program")
}

// printPrime displays prime numbers for the first 5000 numbers.
func printPrime(prefix string) {
    // Schedule the call to Done to tell main we are done.
    defer wg.Done()
next:
    for outer := 2; outer < 5000; outer++ {
        for inner := 2; inner < outer; inner++ {
            if outer%inner == 0 {
                continue next
            }
        }
        fmt.Printf("%s:%d\n", prefix, outer)
    }

    fmt.Println("Completed", prefix)
}
```
上面代码创建了两个goroutine,  打印1到5000之内的素数。查找并显示素数会花费一些十斤啊，这样调度器就能在goroutine首次运行但没有完成查找所有素数之前进行时间分片。

当程序启动，它声明了WaitGroup变量，并将其值设置为2. 两个goroutine通过go关键词加函数printPrime调用被创建。第一个goroutine给了一个A前缀，第二个给了B前缀。就像所有调用函数，参数可以传入创建goroutine的函数。返回参数在goroutine终止的时候不可用。当你看到输出结果，你会看到调度器切换goroutine.

你可以看到类似的输出:
Create Goroutines
Waiting To Finish
B:2
B:3
...
B:4583
B:4591
A:3             切换goroutine
A:5
...
A:4561
A:4567
B:4603          切换goroutine
B:4621
...
Completed B
A:4457          切换goroutine
A:4463
...
A:4993
A:4999
Completed A
Terminating Program

当然，如果你没有看到切换的话，可以将5000改成更大的值试试，因为现在的计算机计算能力很强，有可能对于5000内素数查找也非常快，不会发生切换。

goroutine B首先开始显示素数。然后goroutine B在某个素数的时候，调度器切换到goroutine A。然后goroutine A在线程上执行了一段时间，然后又切换回B，如此反复多次， 直到某个goroutine完成，接着另一个goroutine完成，然后就终止程序。 你会发现每次运行这个程序，调度器对于时间分片发生的点会稍有不同。

上面两个代码都展示了调度器如何在单独的逻辑处理器中并行运行goroutine。正如前面陈述的，Go标准库runtime包里边又一个叫做GOMAXPROCS的函数，可以用于设置调度器使用的逻辑处理器的数量。下面代码是在运行时为每个可用物理处理器分配一个逻辑处理器的。接下来的例子我们会让goroutine并行运行。

```
import "runtime"

// Allocate a logical proccessor for every available core.
runtime.GOMAXPROCS(runtime.NumCPU())
```

runtime包为Go语言运行时提供了配置参数的支持。上面代码我们使用了两个runtime包的函数来修改调度器使用的逻辑处理器数量。runtime.NumCPU()返回可用的物理处理器数量；因此，函数调用GOMAXPROCS()函数为每个物理处理器创建了一个逻辑处理器。需要注意的重要一点是使用一个逻辑处理器以上不一定意味着更好的性能。需要基准测试来理解当配置runtime参数变化时程序如何执行。

如果给调度器多个逻辑处理器使用，我们会看到我们程序给出的输出行为有所不同。下面让我们看看，如果我们将打印英文字母的程序中逻辑处理器的数量改成2会发生什么变化。

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

func main() {
	runtime.GOMAXPROCS(2)

	var wg sync.WaitGroup
	wg.Add(2)

	fmt.Println("Start Goroutines")

	// Declare an anonymous function and create an goroutine.
	go func() {
		// Schedule the call to Done to tell main we are done.
		defer wg.Done()

		// Display alphabet three times.
		for count := 0; count < 3; count++ {
			for char := 'a'; char < 'a'+26; char++ {
				fmt.Printf("%c ", char)
			}
		}
	}()

	// Declare an anonymous function and create an goroutine.
	go func() {
		// Schedule the call to Done to tell main we are done.
		defer wg.Done()

		// Display alphabet three times.
		for count := 0; count < 3; count++ {
			for char := 'A'; char < 'A'+26; char++ {
				fmt.Printf("%c ", char)
			}
		}
	}()

	fmt.Println("Waitting to Finish")
	wg.Wait()

	fmt.Println("\nTerminating Program")
}
```

打印结果如下:
Start Goroutines
Waitting to Finish
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L a b c d e f g M N h i j k l m n o p q r s t u O P Q R S T U V W v w x y z a b c d e f g h i j k l m n o p q X Y Z r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z 
Terminating Program

注意这里的输出和前面我们设置一个逻辑处理器的时候，明显不同，因为我们这里为调度器设置了两个逻辑处理器，允许goroutine并行执行。

仔细看上面的输出，你会看到goroutine是并行运行。几乎是两个goroutine开始运行就立即产生两个goroutine的交叉输出。记住goroutine在单个可用物理处理器上使用多个逻辑处理器的情况下，只能并行运行，每个goroutine同时运行。

你现在知道如何创建goroutine, 理解在引擎盖下面发生了什么。接下来你需要理解的是在写并发程序时的潜在危险和注意事项。

## 6.3 竞态条件(race conditions)
当两个以上goroutine以非同步的方式访问共享资源并尝试同时读写资源，就遇到所谓的竞态条件。竞态条件是并发程序复杂和具有更大的潜在bug的原因。共享资源的读写必须总是原子的(atomic), 或者换句话说，就是同一时间只能一个goroutine来操作。

下面我们看一个有竞态条件的程序例子:

```go
// This sample program demonstrates how to create race conditions in our programs. We don't want to do this.
package main

import (
	"fmt"
	"runtime"
	"sync"
)

var (
	// counter is variable incremented by all goroutines.
	counter int

	// wg is used to wait for program to finish.
	wg sync.WaitGroup
)

func main() {
	// Add a count of two, one for each goroutine.
	wg.Add(2)

	// Create two goroutines.
	go incCounter(1)
	go incCounter(2)

	// Waiting for goroutines to finish.
	wg.Wait()
	fmt.Println("Final Counter:", counter)
}

// incCounter increments the package level counter variable.
func incCounter(id int) {
	// Schedule the call to Done to tell main we are done.
	defer wg.Done()

	for count := 0; count < 2; count++ {
		// Capture the counter.
		value := counter

		// Yield the thread and be placed back in queue.
		runtime.Gosched()

		// Increment our local value of Counter.
		value++
		// Store the value back into Counter.
		counter = value
	}
}
```

上面程序编译后执行，输出结果为:
Final Counter: 2，有时候输出Final Counter 3, 有时候输出Final Counter 4。原书说输出第一种结果，我是在macbook中测试多次得到的多次结果。

counter变量读写四次，每个goroutine分别两次，但是counter变量的值在终止的时候是2, 3或4. 图6.5提供了为什么发生这样事情的线索。

每个goroutine覆盖其他goroutine的工作。 这在goroutine切换的时候发生。 每个goroutine都复制了counter变量的自己副本，然后切换到其他goroutine。
Each goroutine overwrites the work of the other. This happens when the goroutine swap is taking place. Each goroutine makes its own copy of the counter variable and then is swapped out for the other goroutine. When the goroutine is given time to exe- cute again, the value of the counter variable has changed, but the goroutine doesn’t update its copy. Instead it continues to increment the copy it has and set the value back to the counter variable, replacing the work the other goroutine performed.
## 6.4 共享资源锁

## 6.5 通道

## 6.6 总结
- 并发是goroutine的独立执行.
- 函数通过关键词go创建goroutine。
- goroutine是在一个逻辑处理器的作用域中执行，这个逻辑处理器拥有单个操作系统线程，并以队列运行。
- 竞态条件是当两个或多个goroutine尝试访问同样的资源。
- 原子函数和互斥提供了一种保护竞态条件的方式。
- 通道是内在的提供两个goroutine进行安全共享数据的方式。
- 无缓冲通道提供了数据交换间的保证. 缓冲通道不提供。

## 中英文对照
- 少即是多哲学道尽语言精髓: This less-is-more philosophy is a mantra of the language.
- 存在期: lifespan
- 信号量: semaphore
- 引擎盖下发生了什么: what's happening under the hood. 

## 链接

- [上一章节](5.1.md)
- [目录](../README.md)
- [下一章节](7.1.md)
