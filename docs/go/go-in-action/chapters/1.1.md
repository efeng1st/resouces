第一章 Go语言介绍
=================

本章解决如下问题:
1. 使用Go语言解决现代计算挑战
2. 使用go命令

计算机已经进化了，但是编程语言并没有跟上进化步伐。我们携带的手机都可以拥有比我们使用的第一台电脑更多的核。高功率服务器现在都有64，128甚至更高的核，但是我们仍然使用过去我们使用的单核技术来编程。

编程艺术也进化了。 很多程序也不再由单个开发者实现的了: 由坐在不同时区不同时间的团队成员实现。大项目被拆分成小片分配给程序员，然后由程序员将他们的工作以类库或包的形式传回团队, 而且这些类库和包可以跨越应用的整个包可用。

当今的程序员和公司比以往更相信开源软件的强大。Go是一种让代码分享变得更容易的语言。Go附带工具可以使得使用其他人写的包变得更简单，Go也更加容易共享自己的包。

本章你会看到Go和其他语言的不同之处。Go反思你可能使用的传统面向对象开发, 同时仍然提供有效的代码复用方式。Go更容易有效使用你的昂贵服务器的多核特性，这样能大大降低大型项目的编译代价。

阅读本章的过程中，你会感觉到Go的创造适合很多决定，从它的并发模型到快速编译。我们在序言中有提到过，但值得重复: 本书是为具有一些其他编程语言经验并且想学Go语言的中级开发人员所写。我们写本书的目标是为你提供强化、全面和真实的语言观。我们专注于语言规范和实现，包括语言语法、Go类型系统、并发、通道、测试等多方面的主题。我们相信本书对于那些想要跳跃性学习Go语言或者希望彻底理解语言和其内核的人都是完美的。

我们希望你能欣赏Go自带的工具可以让开发者的生活变得更轻松。最后，你会明白为什么那么多开发者在新项目的时候会选择Go。

## 1.1 使用Go语言来解决现代编程挑战

Go语言团队竭尽全力解决当今软件开发所面临的问题。为项目选择语言时，开发者在快速开发和性能之间苦苦挣扎。类似C/C++这样的语言执行效率高，而类似Ruby/Python之类的语言开发效率高。Go语言为这矛盾世界提供了桥梁， 它是一种高效语言同时还让开发变得快速。

在我们探索的过程中，你会发现精心设计的特性和简洁的语法。作为一个语言，Go不仅仅被定义它包含什么，而且定义不包含什么。Go语言具有简洁语法，需要记住很少的关键词。Go语言有如此高效的编译器，有时候你会忘记它在运行。作为一名Go开发者，你会明显花费更少的时间用于构建项目。因为Go语言内置并发特性，软件将来扩展使用可用资源无需强制你使用特殊的线程库。Go使用简单有效的类型系统，而类型系统占用面向对象开发的大量开销, 让你更加专注代码复用。Go语言也有垃圾回收器，因此你无需管理自己的内存。下面我们快速看看这些关键特性。

### 1.1.1 Development speed
在C/C++中编译大型应用程序花费时间要比获取一杯咖啡要多很多。下面图1.1展示了办公室鬼混的经典借口XKCD漫画。Go语言通过使用智能编译器和简化依赖解析算法提供了快如闪电般的编译。当构建Go程序时，编译器只需要查找你直接引用的库，而无需遍历类似Java, C/C++中整个依赖链中所有引入库的依赖。

因此，很多Go应用程序在图1.1下编译还会有难度? 另外，整个Go源码树在现代硬件上编译都在20秒以下。

![](images/1.1.jpg?raw=true)

> 领导喊程序员赶紧工作，程序员借口代码正在编译, 领导只能说继续吧。

### 1.1.2 并发
对于程序员来说，最难的是编写一个能有效利用运行它的硬件的有效资源的应用。现代计算机都有很多核，但是很多编程语言没有有效工具可以很容易利用这些额外资源。它们通常需要大量线程同步代码，这样很容易出错。

Go的并发支持是它最强大特性之一。Goroutine类似线程，但是比线程使用更少内存，使用更少的代码。通道是数据结构，允许你使用内置同步在goroutine之间发送类型消息。这样有利于在goroutine之间发送数据的编程模型，而不用让groutine抢用相同的数据。现在让我们更详细地看看这些特性。

**GOROUTINE**

goroutine是与其他goroutine一起运行的功能，包括程序的入口点。在其他语言中，使用线程来完成同样的事情，但是在Go语言中，很多goroutine可以在同一个线程中执行。例如，如果你写了一个web服务器，你要同时处理很多不同的web请求，在C或Java中就需要使用线程写大量额外代码。而在go语言中，net/http库都内置有goroutine。每个入站请求都自动运行在它自己的goroutine中。Goroutine比线程使用更少的内存, 并且Go运行时会根据配置的逻辑处理器来自动调度goroutine的执行。每个逻辑处理器被绑定到单个OS线程。 这样你的应用程序就大大减少开发工作量，效率却更加明显提高。

![](images/1.2.jpg?raw=true)

如果你想要并行执行一些代码，同时继续完成其他的事情，goroutine是完美胜任的。下面是一个快速例子:
```
func log(msg string){
    ... some logging code here
}
// Elsewhere in our code after we've discovered an error.
go log("something dire happened")
```

关键词go是你想要调度log函数以goroutine的形式运行的全部，并且对于这个goroutine会和其他goroutine同时运行。这就意味着你可以继续执行应用程序的其他代码，而logging并行发生，这最终往往能为你的终端用户感觉更大的性能提升。 如前所述，goroutine具有最小的开销，因此它产生成千上万的都没有什么不正常。我们在第六章会探讨goroutine和并发更深入的东西。

**Channel**

通道是数据结构，能在goroutine之间安全的进行数据传输。通道能帮你避免那些允许共享内存访问编程语言中常见的经典问题。

并发最难的部分就是确保数据不被并行运行的进程、线程或goroutine意外的修改。当多线程没有使用锁或同步时修改相同的数据时，心痛总是伴随着的。其他语言中，当你有全局变量或共享内存的时候，需要使用复杂的锁定准则来防止对相同变量的非同步改变。

![](images/1.3.jpg?raw=true)

通道通过提供一种使数据安全免受并行修改的模式来解决这个问题。通道帮助强制在同一时间只能有一个goroutine修改数据的模式。在图1.3中你可以看到这个流程的例子，通道用于在多个运行的goroutine之间发送数据。想象一个应用程序里边有很多不同的进程需要知道或修改数据的顺序。使用goroutine和通道，你可以安全的模拟这个过程。

在图1.3中，有三个goroutine和两个未缓冲的通道。第一个goroutine通过一个channel传递数据给第二个已在等待的goroutine. 两个goroutine之间的数据交换是同步的，一旦发生切换，两个goroutine都知道交换发生了。在第二个goroutine使用数据执行它的任务之后，然后将数据发送给第三个正在等待的goroutine。 交换也是同步的，两个goroutine都能保证交换已经发生。 goroutine之间的数据安全交换不需要其他锁或同步机制。

需要注意的是，通道不提供goroutine之间的数据访问保护。 如果数据拷贝通过通道交换，那么每个goroutine都有它的一份拷贝，可以安全的对数据进行更改。 当指向数据的指针被交换, 如果读写在不同的goroutine间进行，那么每个goroutine仍然需要被同步。

### 1.1.3 Go语言的类型系统
Go语言提供了灵活的层次结构自由的类型系统，它能够以最小的重构开销实现代码复用。它仍然是面向对象开发，但是没有传统面向对象的头痛问题。如果在复杂的Java或C++程序中你曾经花了一个星期计划你的抽象类和接口, 你会感激Go语言的类型系统的简单性。Go语言开发人员只需要用一种叫做组合的设计模式嵌入类型来重用功能。其他语言使用组合，但是通常深深的与继承相连， 这样就会变得复杂而难以使用。 在Go语言中，类型由更小的类型组成，这点是与传统基于继承的模型相反的。

另外Go具有独特的接口实现，允许你建模行为，而不是建模类型。在Go语言中你无需声明你正在实现一个接口, 编译器来完成这个事情，决定你的类型值是否满足你使用的接口。 在Go语言标准库中很多接口非常小，仅仅暴露很少的功能。 在实践中，这需要一些时间来适应，特别是你如果正在使用类似Java这样的面相对象语言。

**TYPES ARE SIMPLE**

Go has built-in types like int and string as well as user-defined types. A typical user- defined type in Go will have typed fields to store data. If you’ve seen structs in C, Go’s user-defined types will look familiar and operate similarly. But types may also declare methods that operate on that data. Rather than building a long inheritance struc- ture—Client extends User extends Entity—Go developers build small types—Cus- tomer and Admin—and embed them into larger ones. Figure 1.4 demonstrates the difference between inheritance and composition.

### 1.1.4 Memory management

## 中英文对照 
- 强化、全面和真实的语言观: intensive, comprehensive, and idiomatic view of the language
- 竭尽全力: go to great lengths
- 办公室鬼混经典借口: classic excuse for messing around in the office
- XKCD: 由兰德尔·门罗（Randall Munroe）创作的网络漫画
- 快如闪电: lightning-quick
- 并发: Concurrency
- 切换: hand-off

## 链接
- [目录](../README.md)
- [下一节](1.2.md)
