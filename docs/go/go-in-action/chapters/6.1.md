第六章 并发
=============
本章概要
- 使用goroutine运行代码
- 检测和修复竞态条件
- 使用通道共享数据

通常程序可以以线性路径代码实现来执行简单任务并完成。如果这是可能的，我们通常选择这种方式，因为这样类型的编程通常简单易写，并且容易维护。但是很多时候并行执行多个任务有更多好处。 一个常见例子就是web服务器，可以同时接收多个独立socket上的数据请求。每个socket请求都是独立的，可以独立处理。具有并行执行请求的能力可以极大的提升这种类型系统的性能。就是因为考虑到这一点，Go语言已经将并行内置到语言系统和运行系统中。

Go语言中的并发就是独立运行每个功能的能力。 当函数使用goroutine创建，它就被视为一个独立的工作单元，会被调度并在单个可用的逻辑处理器上执行。Go运行时调度器是一个复杂的软件，它管理创建的所有goroutine和所需的处理器时间。调度器位于操作系统顶层，绑定操作系统线程到逻辑处理器,反过来它们执行goroutine。调度器控制所有goroutine在何时运行在哪个逻辑处理器这些事情。

并发同步来自叫做通信顺序处理(CSP)的范式。CSP是一个消息传递模型，通过在goroutine之间通信数据来工作，而不是锁定数据来同步访问实现。goroutine之间用于同步和传递消息的关键数据类型叫做channel(通道)。对很多没有体验过用通道写并行程序的开发者来说， 它们唤起了一种敬畏和兴奋的气氛，你也很希望体验一下吧。 使用通道使你很容易开发并行程序，并且更少犯错。

## 6.1 并发和并行(Concurrency versus parallelism)
让我们从高层次来学习操作系统进程和线程是什么。这会帮助我们理解后续的Go运行时调度如何和操作系统操作来并行运行goroutine。当你运行一个应用程序是，比如IDE或编辑器，操作系统为这个应用程序启动一个进程。你可以认为进程就像一个容器，保存应用程序使用和维持运行的资源。

图6.1展示了包含可能分配个任意进程的通用资源。 这些资源包括但不限于内存地址空间、文件处理器、设备和线程。线程是执行路径，由操作系统调度来运行你所写功能的代码。每个进程包含至少一个线程，进程的最初始化的线程叫做主线程。当主线程终止，应用程序就终止了，因为这个执行路径是应用程序的起源。 操作系统调度线程在处理器上来运行，而不管进程属于哪个处理器。不同操作系统使用的算法用于调度线程，总是变化的，都是来自程序员抽象的。

![](images/6.1.jpg)

操作系统调度让线程在物理处理器上运行，Go运行时调度让goroutine在逻辑处理器上运行。每个逻辑处理器都是独立绑定到单个操作系统线程。1.5版本的，默认的为每个物理处理器分配逻辑处理器已可用。 1.5版本之前，只默认分配一个单独的逻辑处理器。 这些逻辑处理器用于执行创建的所有goroutine. 即便在单个逻辑处理器中，成千上万个goroutine可以被调度来并发运行, 并具有令人吃惊的效率和性能。

图6.2， 你可以看到操作系统线程(逻辑处理器)和本地运行队列之间的关系。 随着goroutine的创建和运行就绪，它们被放到调度器的全局运行队列。之后不久，它们被赋予给逻辑处理器，然后放入那个逻辑处理器的逻辑运行队列。从这里，goroutine等待自己变成特定逻辑处理器来执行。

![](images/6.2.jpg)

有时候运行goroutine
Sometimes a running goroutine may need to perform a blocking syscall, such as open- ing a file. When this happens, the thread and goroutine are detached from the logical processor and the thread continues to block waiting for the syscall to return. In the meantime, there’s a logical processor without a thread. So the scheduler creates a new thread and attaches it to the logical processor. Then the scheduler will choose another goroutine from the local run queue for execution. Once the syscall returns, the goroutine is placed back into a local run queue, and the thread is put aside for future use.
If a goroutine needs to make a network I/O call, the process is a bit different. In this case, the goroutine is detached from the logical processor and moved to the run- time integrated network poller. Once the poller indicates a read or write operation is ready, the goroutine is assigned back to a logical processor to handle the operation. There’s no restriction built into the scheduler for the number of logical processors that can be created. But the runtime limits each program to a maximum of 10,000 threads by default. This value can be changed by calling the SetMaxThreads function from the runtime/debug package. If any program attempts to use more threads, the program crashes.
Concurrency is not parallelism. Parallelism can only be achieved when multiple pieces of code are executing simultaneously against different physical processors. Par- allelism is about doing a lot of things at once. Concurrency is about managing a lot of things at once. In many cases, concurrency can outperform parallelism, because the strain on the operating system and hardware is much less, which allows the system to do more. This less-is-more philosophy is a mantra of the language.
If you want to run goroutines in parallel, you must use more than one logical pro- cessor. When there are multiple logical processors, the scheduler will evenly distribute goroutines between the logical processors. This will result in goroutines running on different threads. But to have true parallelism, you still need to run your program on a machine with multiple physical processors. If not, then the goroutines will be run- ning concurrently against a single physical processor, even though the Go runtime is using multiple threads.
Figure 6.3 shows the difference between running goroutines concurrently against a single logical processor and concurrently in parallel against two logical processors. It’s not recommended to blindly change the runtime default for a logical processor. The scheduler contains intelligent algorithms that are updated and improved with every release of Go. If you’re seeing performance issues that you believe could be resolved by changing the number of logical processors, you have the ability to do so. You’ll learn more about this soon.
## 6.6 总结

- 并发是goroutine的独立执行.
- 函数通过关键词go创建goroutine。
- goroutine是在一个逻辑处理器的作用域中执行，这个逻辑处理器拥有单个操作系统线程，并以队列运行。
- 竞态条件是当两个或多个goroutine尝试访问同样的资源。
- 原子函数和互斥提供了一种保护竞态条件的方式。
- 通道是内在的提供两个goroutine进行安全共享数据的方式。
- 无缓冲通道提供了数据交换间的保证. 缓冲通道不提供。

## 链接

- [上一章节](5.1.md)
- [目录](../README.md)
- [下一章节](7.1.md)
