# 8.1 声明、初始化和make

## 8.1.1 概念

map是引用类型，可以使用如下声明：

```go
var map1 map[keytype]valuetype
var map1 map[string]int
```

（`[keytype]` 和 `valuetype` 之间允许有空格，但是 gofmt 移除了空格）

在声明的时候不需要知道map的长度，map是可以动态增长的。

未初始化的map的值是nil。

key可以是任意可以用==或者!=操作符比较的类型，比如string、int、float。所以数组、切片和结构体不能作为key(译者注：含有数组切片的结构体不能作为key，只包含内建类型的struct是可以作为key的)，但是指针和接口类型可以。如果要用结构体作为key可以提供`Key()`和`Hash()`方法，这样可以通过结构体的域计算出唯一的数字或者字符串的key。

value可以是任意类型的；通过使用空接口类型(详见第11.9节)，我们可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言(详见第11.3节)。

map传递给函数的代价很小：在32位机器上占4个字节，64位机器上占8个字节，无论实际上存储了多少数据。通过key在map中寻找值是很快的，比线性查找快得多，但是仍然比从数组和切片的索引中直接读取要慢100倍；所以如果你很在乎性能的话还是建议用切片来解决问题。

map也可以用函数作为自己的值，这样就可以用来做分支结构(详见第5章)：key用来选择要执行的函数。

如果key1是map1的key，那么`map1[key1]`就是对应key1的值，就如同数组索引符号一样(数组可以视为一种简单形式的map，key是从0开始的整数)。

key1对应的值可以通过赋值符号来设置为val1：`map1[key1] = val1`。

令`v := map1[key1]`可以将key1对应的值赋值为v；如果map中没有key1存在，那么v将被赋值为map1的值类型的空值。

常用的`len(map1)`方法可以获得map中的pair数目，这个数目是可以伸缩的，因为map-pairs在运行时可以动态添加和删除。

示例 8.1 [make_maps.go](examples/chapter_8/make_maps.go)

```go
package main
import "fmt"

func main() {
	var mapLit map[string]int
	//var mapCreated map[string]float32
	var mapAssigned map[string]int

	mapLit = map[string]int{"one": 1, "two": 2}
	mapCreated := make(map[string]float32)
	mapAssigned = mapLit

	mapCreated["key1"] = 4.5
	mapCreated["key2"] = 3.14159
	mapAssigned["two"] = 3

	fmt.Printf("Map literal at \"one\" is: %d\n", mapLit["one"])
	fmt.Printf("Map created at \"key2\" is: %f\n", mapCreated["key2"])
	fmt.Printf("Map assigned at \"two\" is: %d\n", mapLit["two"])
	fmt.Printf("Map literal at \"ten\" is: %d\n", mapLit["ten"])
}
```

输出结果：

	Map literal at "one" is: 1
	Map created at "key2" is: 3.14159
	Map assigned at "two" is: 3
	Mpa literal at "ten" is: 0

mapLit说明了`map literals`的使用方法：map可以用`{key1: val1, key2: val2}`的描述方法来初始化，就像数组和结构体一样。

map是**引用类型**的：内存用make方法来分配。

map的初始化：`var map1 = make(map[keytype]valuetype)`。

或者简写为：`map1 := make(map[keytype]valuetype)`。

上面例子中的mapCreated 就是用这种方式创建的：`mapCreated := make(map[string]float32)`。

相当于：`mapCreated := map[string]float32{}`。

mapAssigned也是mapList的引用，对mapAssigned的修改也会影响到 mapLit 的值。

**不要使用 new，永远用 make 来构造 map**

**注意** 如果你错误的使用new()分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：

```go
mapCreated := new(map[string]float32)
```

接下来当我们调用：`mapCreated["key1"] = 4.5` 的时候，编译器会报错：

	invalid operation: mapCreated["key1"] (index of type *map[string]float32).

为了说明值可以是任意类型的，这里给出了一个使用 `func() int` 作为值的 map：

示例 8.2 [map_func.go](examples/chapter_8/map_func.go)

```go
package main
import "fmt"

func main() {
	mf := map[int]func() int{
		1: func() int { return 10 },
		2: func() int { return 20 },
		5: func() int { return 50 },
	}
	fmt.Println(mf)
}
```

输出结果为：`map[1:0x10903be0 5:0x10903ba0 2:0x10903bc0]`: 整形都被映射到函数地址。

## 8.1.2 map容量

和数组不同，map可以根据新增的key-value对动态的伸缩，因此它不存在固定长度或者最大限制。但是你也可以选择标明map的初始容量`capacity`，就像这样：`make(map[keytype]valuetype, cap)`。例如：

```go
map2 := make(map[string]float32, 100)
```

当map增长到容量上限的时候，如果再增加新的key-value对，map的大小会自动加1。所以出于性能的考虑，对于大的map或者会快速扩张的map，即使只是大概知道容量，也最好先标明。

这里有一个map的具体例子，即将音阶和对应的音频映射起来：

```go
noteFrequency := map[string]float32 {
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87, "A4": 440}
```

## 8.1.3 用切片作为map的值

既然一个key只能对应一个value，而value又是一个原始类型，那么如果一个key要对应多个值怎么办？例如，当我们要处理unix机器上的所有进程，以父进程(pid 为整形)作为key，所有的子进程(以所有子进程的pid组成的切片)作为value。通过将value定义为`[]int`类型或者其他类型的切片，就可以优雅的解决这个问题。

这里有一些定义这种map的例子：

```go
mp1 := make(map[int][]int)
mp2 := make(map[int]*[]int)
```

## 链接

- [目录](directory.md)
- 上一节：[Map](08.0.md)
- 下一节：[测试键值对是否存在及删除元素](08.2.md)
