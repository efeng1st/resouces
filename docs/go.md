# Go语言

## Go语言结构
Go语言的基础组成部分有以下几个部分:
* 包申明: package pkgname
* 引入包: import "pkgname", 或者import ("pkgname1", "pkgname2")
* 函数: func fname() {}
* 变量: var vname := value
* 语句和表达式: 
* 注释: 单行注释和多行注释，同php

```
package main

import "fmt"

func main() {
    /* 这里是注释 */
    fmt.Println("Hello World!")
}
```
1. go程序代码非注释第一行指明文件属于哪个包。例如: package main， 它表示一个可独立执行的程序，每个go语言程序都包含一个名为main的包。
2. import "fmt"告诉go编译器这个程序需要fmt包，fmt包实现了格式化I/O的函数
3. func main()是程序开始执行的函数。main函数是每一个可执行程序所必需包含的，一般来说都是在启动后第一个执行的函数(如果有init函数则会先执行该函数).
4. go语言的注释有两种: 单行注释和多行注释，使用过php的对这两种注释方式非常熟悉了。
5. fmt.Println()将字符串输出到控制台，并在最后自动增加换行字符"\n".
6. go语言的标识符(包括常量、变量、类型、函数名、结构字段等等)以一个大写字母开头的，使用这种形式的标识符的对象就可以被外部包的代码索使用(客户端程序需要先导入这个包), 这被称为导出(像面向对象语言中的public); 标识符如果使用小写字母开头，则对外包是不可见的，但是它们在整个包的内部是可见并且可用的(像面向对象语言中的protected)。

## 执行go程序

```
go install hello.go
```

## go语言的数据类型
在go语言中，数据类型用于声明函数和变量。

数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候菜需要申请大内存，就可以充分利用内存。

go语言的数据类型:
1. 布尔值: 布尔型的值只可以是常量true和false。 一个简单的例子: var b bool = false
2. 数字类型: 整型int和浮点型float32, float64, Go语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码.
3. 字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。go语言的字符串的字节使用UTF-8编码标识Unicode。
4. 派生类型: 包括指针类型、数组类型、结构化类型、Channel类型、函数类型、切片类型、接口类型、Map类型

### 数字类型
go也有基于架构的类型，例如int, uint和uintptr。数字类型有无符号类型和有符号类型，包括8位、16位、32位、64位。因此总共有8种整型类型:
1. uint8: 无符号8位整型(0 - 255).
2. uint16: 无符号16位整型(0 - 65535).
3. uint32: 无符号32位整型(0 - 4294967295).
4. uint64: 无符号64位整型(0 - 18446744073709551615).
5. int8: 有符号8位整型(-128 - 127).
6. int16: 有符号16位整型 (-32768 到 32767).
7. int32: 有符号 32 位整型 (-2147483648 到 2147483647).
8. int64: 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807).

浮点型包含32位、64位的浮点数和复数。
1. float32: IEEE-754 32位浮点型数
2. float64: IEEE-754 64位浮点型数。
3. complex64: 32位实数和虚数。
4. complex128: 64位实数和虚数。

除了上面的整型、浮点数和复数外，go还有一些其他类型的数字类型:
1. byte: 字节类型， 类似uint8
2. rune: int32的别名，用于表示Unicode的code point.
3. uint: 32位或64位，自动根据系统识别。
4. int: 和unit类似，32位或64位。
5. uintptr: 无符号整型，用于存放一个指针。

## go语言变量
变量来源于数学，是计算机语言中能存储计算结果或能表示值抽象概念。变量可以通过变量名访问。
go语言变量名由字母、数字、下划线组成，其中首个字母不能为数字。声明变量使用var关键词:
```
var indentifier type
```

声明变量的三种方式:
1. 指定变量类型，声明后若不赋值，使用默认值:
```
var v_name v_type
v_name = value
```
2. 根据值自行判定变量类型
```
var v_name = v_value
```
3. 省略var, 注意:=左侧的变量不应该是已经声明过的，否则会导致编译错误。
```
v_name := v_value
```

go语言可以一次声明多个变量:
```
// 类型相同多个变量，非全局变量
var vname1, vname2, vname3 type
vname1, vname2, vname3 = v1, v2, v3

var vname1, vname2, vname3 = v1, v2, v3 // 不需要显示声明类型，自动推断，和python类似

// 下面这种分解关键字的写法一般用于声明全局变量
var (
    vname1 v_type1
    vname2 v_type2
)
```

### 值类型和引用类型
所有像int, float, bool, string这些基本类型都属于值类型，使用这些变量直接指向内存中的值。对于值类型的变量，使用=赋值实际上是在内存中将值进行了拷贝。

我们可以使用&vname来获取变量vname的内存地址. 值类型的变量的值存储在栈中。内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。

更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。引用类型的变量r1的值存储的是r1的值所在的内存地址(数字), 或内存地址中第一个字所在的位置。这个内存地址称为指针，这个指针实际上也被存在另外的某一个字中。

同一个引用类型的指针指向多个字可以在连续的内存地址中(内存布局是连续的), 这也是计算效率最高的一种存储形势； 也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。 当使用赋值语句r2 = r1时，只有引用被复制。 如果r1的值被改变了，那么这个值的所有引用都会指向被修改后的内容。

### 简短形式，使用:=赋值操作符
这种声明变量的方式会自动根据值类型进行推断。是使用变量的首选形式，但是需要注意的是它只能使用在函数体内，不能使用在全局变量的声明与赋值。 使用操作符:=可以高效的创建一个新的变量，称之位初始化声明。

注意事项:
1. 对于简短形式的变量声明，不能对已经申明的变量使用:=赋值，否则会编译报错。 
2. 变量必须先声明，再使用，否则会编译报错。
3. 如果声明了局部变量，但是没有在相同的代码中使用它，同样会得到编译错误.
4. 全局变量可以只声明但不使用。
5. 并行赋值或同时赋值: a, b, c := av, bv, cv。并行赋值可以用于获取函数的多个返回值。
6. 交换a, b值: a, b = b, a
7. 抛弃值: `_, b = 5, 7`, 下划线是一个只写变量，不能得到它的值。 这样做是因为go语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。

## go常量
常量是一个简单值的标识符，在程序运行时，不会被修改的量。
常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

常量的定义格式：
```
const identifier [type] = value
```

常量通常用于不变值、枚举.

```
const PI = 3.1415926

// 定义枚举类型常量
const (
    UnKnown = 0
    Female = 1
    Male = 2
)

// 使用len(), cap(), unsafe.Sizeof()等内置函数计算表达式的值定义常量
const ( 
    a = "abc"
    b = len(a)
    c = unsafe.Sizeof(a)
)
```

### iota 特殊常量
可以认为是一个可以被编译器修改的常量。
```
const (
    a = iota
    b = iota
    c = iota
)
```
第一个iota等于0，每当iota在新的一行被使用时，它的值会自动加1；所以a=0, b=1, c=2, 也可以简写如下:
```
const (
    a = iota
    b
    c
)
```

iota用法
```
package main

import "fmt"

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
}
```

以上实例运行结果为:
```
0 1 2 ha ha 100 100 7 8
```


另外一个iota有趣的例子:
```
package main

import "fmt"
const (
    i=1<<iota
    j=3<<iota
    k
    l
)

func main() {
    fmt.Println("i=",i)
    fmt.Println("j=",j)
    fmt.Println("k=",k)
    fmt.Println("l=",l)
}
```
以上运行结果为:
```
i= 1
j= 6
k= 12
l= 24
```

iota表示从0开始自动加1，所以 i=1<<0, j=3<<1（<<表示左移的意思），即：i=1,j=6，这没问题，关键在k和l，从输出结果看 k=3<<2，l=3<<3。

简单表述:

* i=1：左移 0 位,不变仍为 1;
* j=3：左移 1 位,变为二进制 110, 即 6;
* k=3：左移 2 位,变为二进制 1100, 即 12;
* l=3：左移 2 位,变为二进制 11000,即 24。

## go语言条件语句

条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为true来决定是否执行语句，并在条件为false的情况下执行另外的语句。

go语言的条件判断语句有:
1. if语句: 由一个布尔表达式后紧跟一个或多个语句组成。
2. if...else语句: if语句后可以使用可选的else语句, else语句中的表达式在布尔表达式为false时执行。
3. if嵌套语句: 可以在if或else if语句中嵌套一个或多个if或else if语句。
4. switch语句: switch语句用于基于不同条件执行不同动作。
5. select语句: select语句类似于switch语句，但是select语句会随机执行一个可运行的case. 如果没有case可运行，它将阻塞，知道有case可运行。


## 参考链接
1. https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md
